#!/bin/dash
# Copyright 2024 (Holloway) Chew, Kean Ho <hello@hollowaykeanho.com>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at:
#                 http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.




# HOW TO USE:
#       (1) Change directory to inside HestiaSTRING where this script is
#           located. Example:
#               $ cd /path/to/HestiaSTRING/
#
#       (2) Set this script to executable. Example:
#               $ chmod +x ./unicode-data-parser.sh
#
#       (3) Download the UnicodeData.txt and SpecialCasing.txt from:
#               (I)     https://unicode.org/Public/UNIDATA/UnicodeData.txt
#               (II)    https://unicode.org/Public/UNIDATA/SpecialCasing.txt
#           and place them right next to the parser script.
#
#       (4) Execute the parser script to generate the latest rune case switchers
#           source codes. To enable debug mode, simple set the
#           'DEBUG_MODE="true"' environment variable before execute. Example:
#               production mode : $ ./unicode-data-parser.sh
#               debug mode      : $ DEBUG_MODE="true" ./unicode-data-parser.sh
#
#       (5) Remove the executable permission once all outpus are created.
#           Example:
#               $ chmod -x ./unicode-data-parser.sh




# printer function for generating .ps1 (PowerShell) library script.
print_to_ps1() {
        # execute
        case "$6" in
        debug)
                printf -- "%s" "\
# param 1: ${1}
# param 2: ${2}
# param 3: ${3}
# param 4: ${4}
# param 5: ${5}
# param 6: ${6}
# param 7: ${7}
"
                ;;
        start)
                # write the header and be done with it
                printf -- "%s" "\
# Copyright $(date -u +"%Y") HestiaKERNEL Authors
#
#
# BSD 3-Clause License
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# WARNING - Autogenerated script from 'HestiaKERNEL/src/unicode/data-parser.sh'.
#           DO NOT EDIT MANUALLY!
"
                case "$7" in
                lowercase)
                        printf -- "%s" "\




function hestiastring-rune-to-lower {
"
                        ;;
                uppercase)
                        printf -- "%s" "\




function hestiastring-rune-to-upper {
"
                        ;;
                titlecase)
                        printf -- "%s" "\

. \"\${env:LIBS_HESTIA}\\HestiaSTRING\\rune_to_lower.ps1\"
. \"\${env:LIBS_HESTIA}\\HestiaSTRING\\rune_to_upper.ps1\"




function hestiastring-rune-to-title {
"
                        ;;
                *)
                        printf -- "%s" "\




function hestiastring-switch-case {
"
                        ;;
                esac

                printf -- "%s" "\
        param (
                [int]\$___char_decimal,
                [int]\$___next_decimal,
                [int]\$___third_decimal,
                [string]\$___locale
        )


        # validate input
        if (\$___char_decimal -eq \"\") {
                # ERROR - bad input
                return \"\"
        }
"
                ;;
        special_start_lower)
                printf -- "%s" "\


        # language sensitive special cases
        switch -Wildcard (\$___locale) {
        { \$_ -in \"az*\", \"tr*\" } {
                # Turkish & Azerbaijani
                switch (\$___char_decimal) {
                0x0130 {
                        return \"\
[1]$(printf -- "%d" "0x0069")\
\"
                } 0x0049 {
                        switch (\$___next_decimal) {
                        0x0307 {
                                return \"\
[2]$(printf -- "%d" "0x0069")\
\"
                        } default {
                                return \"\
[1]$(printf -- "%d" "0x0131")\
\"
                        }}
                }}
        } \"lt*\" {
                # Lithuanian
                switch (\$___char_decimal) {
                0x0049 {
                        return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307")\
\"
                } 0x004A {
                        return \"\
[1]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                } 0x012E {
                        return \"\
[1]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                } 0x00CC {
                        return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                } 0x00CD {
                        return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                } 0x0128 {
                        return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303")\
\"
                }}
        }}


        # language insensitive special cases
        switch (\$___char_decimal) {
        \"powershell-language-adjusting-first-case\" {
                # just to make the first case consistent with others (as in
                # programming languages) without breaking the parser just for
                # PowerShell specific requirement.
"
                ;;
        special_start_title)
                printf -- "%s" "\


        # language sensitive special cases
        switch -Wildcard (\$___locale) {
        { \$_ -in \"az*\", \"tr*\" } {
                # Turkish & Azerbaijani
                switch (\$___char_decimal) {
                0x0049 {
                        switch (\$___next_decimal) {
                        0x0307 {
                                if (\$___to_title -ne \"\") {
                                        return \"\
[2]$(printf -- "%d" "0x0049"), $(printf -- "%d" "0x0307")\
\"
                                } else {
                                        return \"\
[2]$(printf -- "%d" "0x0069")\
\"
                                }
                        } default {
                                if (\$___to_title -ne \"\") {
                                        return \"\
[1]$(printf -- "%d" "0x0049")\
\"
                                } else {
                                        return \"\
[1]$(printf -- "%d" "0x0131")\
\"
                                }
                        }}
                } { \$_ -in 0x0069, 0x0130 } {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x0130")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x0069")\
\"
                        }
                }}
        } \"lt*\" {
                # Lithuanian
                switch (\$___char_decimal) {
                0x0049 {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x0049")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307")\
\"
                        }
                } 0x004A {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x004A")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                        }
                } 0x0069 {
                        switch (\$___next_decimal) {
                        0x0307 {
                                switch (\$___third_decimal) {
                                0x0300 {
                                        if (\$___to_title -ne \"\") {
                                                return \"\
[3]$(printf -- "%d" "0x00CC")\
\"
                                        } else {
                                                return \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                                        }
                                } 0x0301 {
                                        if (\$___to_title -ne \"\") {
                                                return \"\
[3]$(printf -- "%d" "0x00CD")\
\"
                                        } else {
                                                return \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                                        }
                                } 0x0303 {
                                        if (\$___to_title -ne \"\") {
                                                return \"\
[3]$(printf -- "%d" "0x0128")\
\"
                                        } else {
                                                return \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303")\
\"
                                        }
                                } default {
                                        if (\$___to_title -ne \"\") {
                                                return \"\
[2]$(printf -- "%d" "0x0049")\
\"
                                        } else {
                                                return \"\
[2]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307") \
\"
                                        }
                                }}
                        }}
                } 0x006A {
                        switch (\$___next_decimal) {
                        0x0307 {
                                if (\$___to_title -ne \"\") {
                                        return \"\
[2]$(printf -- "%d" "0x004A")\
\"
                                } else {
                                        return \"\
[2]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                                }
                        }}
                } 0x00CC {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x00CC")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                        }
                } 0x00CD {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x00CD")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                        }
                } 0x0128 {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x0128")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303"), \
\"
                        }
                } 0x012E {
                        if (\$___to_title -ne \"\") {
                                return \"\
[1]$(printf -- "%d" "0x012E")\
\"
                        } else {
                                return \"\
[1]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                        }
                } 0x012F {
                        switch (\$___next_decimal) {
                        0x0307 {
                                if (\$___to_title -ne \"\") {
                                        return \"\
[2]$(printf -- "%d" "0x012E")\
\"
                                } else {
                                        return \"\
[2]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                                }
                        }}
                } 0x0307 {
                        return \"[1]\"
                }}
        }}


        # language insensitive special cases
        switch (\$___char_decimal) {
        \"powershell-language-adjusting-first-case\" {
                # just to make the first case consistent with others (as in
                # programming languages) without breaking the parser just for
                # PowerShell specific requirement.
"
                ;;
        special_start_upper)
                printf -- "%s" "\


        # language sensitive special cases
        switch -Wildcard (\$___locale) {
        { \$_ -in \"az*\", \"tr*\" } {
                # Turkish & Azerbaijani
                switch (\$___char_decimal) {
                0x0069 {
                        return \"\
[1]$(printf -- "%d" "0x0130")\
\"
                } 0x0131 {
                        return \"\
[1]$(printf -- "%d" "0x0049")\
\"
                }}
        } \"lt*\" {
                # Lithuanian
                switch (\$___char_decimal) {
                0x0069 {
                        switch (\$___next_decimal) {
                        0x0307 {
                                switch (\$___third_decimal) {
                                0x0300 {
                                        return \"\
[3]$(printf -- "%d" "0x00CC")\
\"
                                } 0x0301 {
                                        return \"\
[3]$(printf -- "%d" "0x00CD")\
\"
                                } 0x0303 {
                                        return \"\
[3]$(printf -- "%d" "0x0128")\
\"
                                } default {
                                        return \"\
[2]$(printf -- "%d" "0x0049")\
\"
                                }}
                        }}
                } 0x006A {
                        switch (\$___next_decimal) {
                        0x0307 {
                                return \"\
[2]$(printf -- "%d" "0x004A")\
\"
                        }}
                } 0x012F {
                        switch (\$___next_decimal) {
                        0x0307 {
                                return \"\
[2]$(printf -- "%d" "0x012E")\
\"
                        }}
                } 0x0307 {
                        return \"[1]\"
                }}
        }}


        # language insensitive special cases
        switch (\$___char_decimal) {
        \"powershell-language-adjusting-first-case\" {
                # just to make the first case consistent with others (as in
                # programming languages) without breaking the parser just for
                # PowerShell specific requirement.
"
                ;;
        special_change_start)
                # process by indent
                case "$5" in
                3)
                printf -- "%s" "\
                        switch (\$___third_decimal) {
                        ${1} {
"
                        ;;
                2)
                printf -- "%s" "\
                switch (\$___next_decimal) {
                ${1} {
"
                        ;;
                *)
                printf -- "%s" "\
        } ${1} {
"
                        ;;
                esac
                ;;
        special_change)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -gt 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done

                ___condition="$1"
                if [ "$___condition" = "any" ]; then
                        ___condition="default"
                fi

                printf -- "%s" "\
${___indent}} ${___condition} {
"
                ;;
        special_content)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -ge 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done


                # process characters data
                ___buffer="$1"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}return \"[${3}]${___output_data%, }\"
"
                ;;
        special_content_titlecase)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -ge 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done


                # process switch condition brace
                printf -- "%s" "\
${___indent}if (\$___to_title -ne \"\") {
"


                # process to titlecasing
                ___buffer="$2"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"

                        ## print characters data
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}        return \"[${3}]${___output_data%, }\"
"


                # process default condition brace
                printf -- "%s" "\
${___indent}} else {
"


                # process default to lowercasing
                ___buffer="$1"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"

                        ## print characters data
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}        return \"[${3}]${___output_data%, }\"
"


                # process closing brace
                printf -- "%s" "\
${___indent}}
"
                ;;
        special_change_end)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -gt 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done

                printf -- "%s" "\
${___indent}}}
"
                ;;
        special_end)
                printf -- "%s" "\
        }}
"
                ;;
        data_start)
                printf -- "%s" "\


        # switching non-special 1:1 casing now
"
                ;;
        data_start_titlecase)
                printf -- "%s" "\


        # switching non-special 1:1 casing now
        if (\$___to_title -ne \"\") {
                return hestiastring-rune-to-upper \`
                        \$___char_decimal \`
                        \$___next_decimal \`
                        \$___third_decimal \`
                        \$___prev_decimal \`
                        \$___locale
        }

        return hestiastring-rune-to-lower \`
                \$___char_decimal \`
                \$___next_decimal \`
                \$___third_decimal \`
                \$___prev_decimal \`
                \$___locale
}
"
                ;;
        data_first|data_within)
                ___condition="} elseif "
                if [ "$6" = "data_first" ]; then
                        ___condition="if "
                fi

                if [ $1 -eq $2 ]; then
                        printf -- "\
        ${___condition} (\$___char_decimal -eq ${1}) {
"
                else
                        printf -- "\
        ${___condition} ((\$___char_decimal -ge ${1}) -and (\$___char_decimal -le ${2})) {
"
                fi

                if [ $3 -lt 0 ]; then
                        printf -- "\
                return \"[1]\$(\$___char_decimal - ${3#*-})\"
"
                else
                        printf -- "\
                return \"[1]\$(\$___char_decimal + ${3})\"
"
                fi
                ;;
        data_end)
                # write the tailing end condition and be done with it
                printf -- "\
        } else {
                return \"[1]\${___char_decimal}\"
        }
"
                ;;
        end)
                # write the tailing end condition and be done with it
                printf -- "\
}
"
                ;;
        esac
}


# printer function for generating .sh (POSIX Compliant Shell) library script.
print_to_sh() {
        #___val_1="$1"
        #___val_2="$2"
        #___val_3="$3"
        #___val_4="$4"
        #___min_indent="$5"
        #___status="$6"
        #___restriction="$7"


        # execute
        case "$6" in
        debug)
                printf -- "%s" "\
# param 1: ${1}
# param 2: ${2}
# param 3: ${3}
# param 4: ${4}
# param 5: ${5}
# param 6: ${6}
# param 7: ${7}
"
                ;;
        start)
                # write the header and be done with it
                printf -- "%s" "\
#!/bin/sh
# Copyright $(date -u +"%Y") HestiaKERNEL Authors
#
#
# BSD 3-Clause License
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# WARNING - Autogenerated script from 'HestiaKERNEL/src/unicode/data-parser.sh'.
#           DO NOT EDIT MANUALLY!
"
                case "$7" in
                lowercase)
                        printf -- "%s" "\




hestiastring_rune_to_lower() {
"
                        ;;
                uppercase)
                        printf -- "%s" "\




hestiastring_rune_to_upper() {
"
                        ;;
                titlecase)
                        printf -- "%s" "\

. \"\${LIBS_HESTIA}/HestiaSTRING/rune_to_lower.sh\"
. \"\${LIBS_HESTIA}/HestiaSTRING/rune_to_upper.sh\"




hestiastring_rune_to_title() {
"
                        ;;
                *)
                        printf -- "%s" "\




hestiastring_rune_switch_case() {
"
                        ;;
                esac

                printf -- "%s" "\
        ___char_decimal=\"\$1\"
        ___next_decimal=\"\$2\"
        ___third_decimal=\"\$3\"
        ___to_title=\"\$4\"
        ___locale=\"\$5\"


        # validate input
        if [ \"\$___char_decimal\" = \"\" ]; then
                # ERROR - bad input
                printf -- \"\"
                return 1
        fi
"
                ;;
        special_start_lower)
                printf -- "%s" "\


        # language sensitive special cases
        case \"\$5\" in
        az*|tr*)
                # Turkish & Azerbaijani
                case \"\$___char_decimal\" in
                0x0130)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069")\
\"
                        return 0
                        ;;
                0x0049)
                        case \"\$___next_decimal\" in
                        0x0307)
                                printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0069")\
\"
                                return 0
                                ;;
                        *)
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0131")\
\"
                                return 0
                                ;;
                        esac
                        ;;
                esac
                ;;
        lt*)
                # Lithuanian
                case \"\$___char_decimal\" in
                0x0049)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307")\
\"
                        return 0
                        ;;
                0x004A)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                        return 0
                        ;;
                0x012E)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                        return 0
                        ;;
                0x00CC)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                        return 0
                        ;;
                0x00CD)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                        return 0
                        ;;
                0x0128)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303")\
\"
                        return 0
                        ;;
                esac
                ;;
        esac


        # language insensitive special cases
        case \"\$___char_decimal\" in
"
                ;;
        special_start_title)
                printf -- "%s" "\


        # language sensitive special cases
        case \"\$5\" in
        az*|tr*)
                # Turkish & Azerbaijani
                case \"\$___char_decimal\" in
                0x0049)
                        case \"\$___next_decimal\" in
                        0x0307)
                                if [ ! \"\$___to_title\" = \"\" ]; then
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0049"), $(printf -- "%d" "0x0307")\
\"
                                        return 0
                                else
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0069")\
\"
                                        return 0
                                fi
                                ;;
                        *)
                                if [ ! \"\$___to_title\" = \"\" ]; then
                                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0049")\
\"
                                        return 0
                                else
                                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0131")\
\"
                                        return 0
                                fi
                                ;;
                        esac
                        ;;
                0x0069|0x0130)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0130")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069")\
\"
                                return 0
                        fi
                        ;;
                esac
                ;;
        lt*)
                # Lithuanian
                case \"\$___char_decimal\" in
                0x0049)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0049")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307")\
\"
                                return 0
                        fi
                        ;;
                0x004A)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x004A")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                                return 0
                        fi

                        return 0
                        ;;
                0x0069)
                        case \"\$___next_decimal\" in
                        0x0307)
                                case \"\$___third_decimal\" in
                                0x0300)
                                        if [ ! \"\$___to_title\" = \"\" ]; then
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x00CC")\
\"
                                                return 0
                                        else
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                                                return 0
                                        fi
                                        ;;
                                0x0301)
                                        if [ ! \"\$___to_title\" = \"\" ]; then
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x00CD")\
\"
                                                return 0
                                        else
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                                                return 0
                                        fi
                                        ;;
                                0x0303)
                                        if [ ! \"\$___to_title\" = \"\" ]; then
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x0128")\
\"
                                                return 0
                                        else
                                                printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303")\
\"
                                                return 0
                                        fi
                                        ;;
                                *)
                                        if [ ! \"\$___to_title\" = \"\" ]; then
                                                printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0049")\
\"
                                                return 0
                                        else
                                                printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307")\
\"
                                                return 0
                                        fi
                                        ;;
                                esac
                                ;;
                        esac
                        ;;
                0x006A)
                        case \"\$___next_decimal\" in
                        0x0307)
                                if [ ! \"\$___to_title\" = \"\" ]; then
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x004A")\
\"
                                        return 0
                                else
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x006A"), $(printf -- "%d" "0x0307")\
\"
                                        return 0
                                fi
                                ;;
                        esac
                        ;;
                0x00CC)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x00CC")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0300")\
\"
                                return 0
                        fi
                        ;;
                0x00CD)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x00CD")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0301")\
\"
                                return 0
                        fi
                        ;;
                0x0128)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0128")\
\"
                                return 0
                        else
                                printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0069"), $(printf -- "%d" "0x0307"), $(printf -- "%d" "0x0303")\
\"
                                return 0
                        fi
                        ;;
                0x012E)
                        if [ ! \"\$___to_title\" = \"\" ]; then
                                ___output_char=\"\
[1]$(printf -- "%d" "0x012E")\
\"
                                return 0
                        else
                                ___output_char=\"\
[1]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                                return 0
                        fi
                        ;;
                0x012F)
                        case \"\$___next_decimal\" in
                        0x0307)
                                if [ ! \"\$___to_title\" = \"\" ]; then
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x012E")\
\"
                                        return 0
                                else
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x012F"), $(printf -- "%d" "0x0307")\
\"
                                        return 0
                                fi
                                ;;
                        esac
                        ;;
                0x0307)
                        printf -- \"%s\" \"[1]\"
                        return 0
                        ;;
                esac
                ;;
        esac


        # language insensitive special cases
        case \"\$___char_decimal\" in
"
                ;;
        special_start_upper)
                printf -- "%s" "\


        # language sensitive special cases
        case \"\$5\" in
        az*|tr*)
                # Turkish & Azerbaijani
                case \"\$___char_decimal\" in
                0x0069)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0130")\
\"
                        return 0
                        ;;
                0x0131)
                        printf -- \"%s\" \"\
[1]$(printf -- "%d" "0x0049")\
\"
                        return 0
                        ;;
                esac
                ;;
        lt*)
                # Lithuanian
                case \"\$___char_decimal\" in
                0x0069)
                        case \"\$___next_decimal\" in
                        0x0307)
                                case \"\$___third_decimal\" in
                                0x0300)
                                        printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x00CC")\
\"
                                        return 0
                                        ;;
                                0x0301)
                                        printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x00CD")\
\"
                                        return 0
                                        ;;
                                0x0303)
                                        printf -- \"%s\" \"\
[3]$(printf -- "%d" "0x0128")\
\"
                                        return 0
                                        ;;
                                *)
                                        printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x0049")\
\"
                                        return 0
                                        ;;
                                esac
                                ;;
                        esac
                        ;;
                0x006A)
                        case \"\$___next_decimal\" in
                        0x0307)
                                printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x004A")\
\"
                                return 0
                                ;;
                        esac
                        ;;
                0x012F)
                        case \"\$___next_decimal\" in
                        0x0307)
                                printf -- \"%s\" \"\
[2]$(printf -- "%d" "0x012E")\
\"
                                return 0
                                ;;
                        esac
                        ;;
                0x0307)
                        printf -- \"%s\" \"[1]\"
                        return 0
                        ;;
                esac
                ;;
        esac


        # language insensitive special cases
        case \"\$___char_decimal\" in
"
                ;;
        special_change_start)
                # process by indent
                case "$5" in
                3)
                printf -- "%s" "\
                        case \"\$___third_decimal\" in
                        ${1})
"
                        ;;
                2)
                printf -- "%s" "\
                case \"\$___next_decimal\" in
                ${1})
"
                        ;;
                *)
                printf -- "%s" "\
        ${1})
"
                        ;;
                esac
                ;;
        special_change)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -gt 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done

                ___condition="$1"
                if [ "$___condition" = "any" ]; then
                        ___condition="*"
                fi

                printf -- "%s" "\
${___indent}        ;;
${___indent}${___condition})
"
                ;;
        special_content)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -ge 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done


                # process characters data
                ___buffer="$1"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"

                        ## print characters data
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}printf -- \"%s\" \"[${3}]${___output_data%, }\"
${___indent}return 0
"
                ;;
        special_content_titlecase)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -ge 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done


                # process switch condition brace
                printf -- "%s" "\
${___indent}if [ ! \"\$___to_title\" = \"\" ]; then
"


                # process titlecasing characters data
                ___buffer="$2"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"

                        ## print characters data
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}        printf -- \"%s\" \"[${3}]${___output_data%, }\"
${___indent}        return 0
"


                # process default condition brace
                printf -- "%s" "\
${___indent}else
"

                # process default lowercasing chracters data
                ___buffer="$1"
                ___output_data=""
                while [ ! "$___buffer" = "" ]; do
                        ___char="${___buffer%%_*}"
                        ___buffer="${___buffer#${___char}}"
                        if [ "${___buffer%"${___buffer#?}"}" = "_" ]; then
                                ___buffer="${___buffer#_}"
                        fi
                        ___char="0${___char}"

                        ## print characters data
                        ___output_data="${___output_data}$(printf -- "%d" "$___char"), "
                done
                printf -- "%s" "\
${___indent}        printf -- \"%s\" \"[${3}]${___output_data%, }\"
${___indent}        return 0
"


                # process close condition brace
                printf -- "%s" "\
${___indent}fi
"
                ;;
        special_change_end)
                # process indent
                ___indent=""
                ___count="$5"
                while [ $___count -gt 0 ]; do
                        ___indent="${___indent}        "
                        ___count=$(($___count - 1))
                done

                printf -- "%s" "\
${___indent}        ;;
${___indent}esac
"
                ;;
        special_end)
                printf -- "%s" "\
                ;;
        esac
"
                ;;
        data_start)
                printf -- "%s" "\


        # switching non-special 1:1 casing now
"
                ;;
        data_start_titlecase)
                printf -- "%s" "\


        # switching non-special 1:1 casing now
        if [ ! \"\$___to_title\" = \"\" ]; then
                printf -- \"%s\" \"\$(hestiastring_rune_to_upper \"\$1\" \"\$2\" \"\$3\" \"\$4\" \"\$5\")\"
                return \$?
        fi

        printf -- \"%s\" \"\$(hestiastring_rune_to_lower \"\$1\" \"\$2\" \"\$3\" \"\$4\" \"\$5\")\"
        return \$?
}
"
                ;;
        data_first|data_within)
                ___condition="elif"
                if [ "$6" = "data_first" ]; then
                        ___condition="if  "
                fi

                if [ $1 -eq $2 ]; then
                        printf -- "%s" "\
        ${___condition} [ \$___char_decimal -eq ${1} ]; then
"
                else
                        printf -- "%s" "\
        ${___condition} [ \$___char_decimal -ge ${1} ] && [ \$___char_decimal -le ${2} ]; then
"
                fi

                if [ $3 -lt 0 ]; then
                        printf -- "%s" "\
                printf -- \"%s\" \"[1]\$((\$___char_decimal - ${3#*-}))\"
                return 0
"
                else
                        printf -- "%s" "\
                printf -- \"%s\" \"[1]\$((\$___char_decimal + ${3}))\"
                return 0
"
                fi
                ;;
        data_end)
                printf -- "%s" "\
        else
                printf -- \"%s\" \"[1]\${___char_decimal}\"
                return 0
        fi
"
                ;;
        end)
                # write the tailing end condition and be done with it
                printf -- "%s" "\
}
"
                ;;
        esac
}




# This is an intermediate isolating function to make both the parser and printer
# sides of functionalities independent of one another. This permits easier
# continuous improvements where 2 directions are evaluated:
#        (1) add new printer for other programming languages; AND
#        (2) adapting parser changes from unicode.org upstream changes.
#
# Unless absolutely required, this function shall not be modified without good
# reason (e.g. adding new printer).
#
# To make sure it's adaptive for its printing sides, this function uses fixed
# positional flexible definitions parameters. Hence, please go through each
# state for the parameters' conversions' definitions from the parser to the
# printer.
#
# The printer output must always return a string with a leading total scanned
# characters index in this pattern '[INDEX]...char...'. Example: uppercasing an
# 'a' will output '[1]A'. To erase, simply print the index will do. Example:
# '[1]' means ignore current character and there is no characters to work on
# after.
#
# One thing important is that INDEX **MUST** AT MINIMUM BE 1. Otherwise, the
# upper layer will lost sync.
print_output() {
        #...SEE BELOW...
        #...SEE BELOW...
        #...SEE BELOW...
        #...SEE BELOW...
        #___status="$5"
        #___restriction="$6"


        # define list of output filepaths
        ___output_to_lower_sh="./rune_to_lower.sh"
        ___output_to_lower_ps1="./rune_to_lower.ps1"

        ___output_to_upper_sh="./rune_to_upper.sh"
        ___output_to_upper_ps1="./rune_to_upper.ps1"

        ___output_to_title_sh="./rune_to_title.sh"
        ___output_to_title_ps1="./rune_to_title.ps1"


        # execute
        case "$5" in
        start)
                # clean up existing artifact files
                rm -f "$___output_to_lower_sh" &> /dev/null
                rm -f "$___output_to_upper_sh" &> /dev/null
                rm -f "$___output_to_title_sh" &> /dev/null
                rm -f "$___output_to_lower_ps1" &> /dev/null
                rm -f "$___output_to_upper_ps1" &> /dev/null
                rm -f "$___output_to_title_ps1" &> /dev/null
                sync


                # generate create opening clause
                print_to_sh "" "" "" "" "$___indent" "start" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "$___indent" "start" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "" "" "" "" "$___indent" "start" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "" "" "" "" "$___indent" "start" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "$___indent" "start" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "" "" "" "" "$___indent" "start" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        debug)
                ## ... any ...
                ## ... any ...
                ## ... any ...
                ## ... any ...
                ##___status="$5"
                ## ... any ...
                ##
                ## TO:
                ##
                ## ... any ...
                ## ... any ...
                ## ... any ...
                ## ... any ...
                ## ... any ...
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "$2" "$3" "$4" "$5" "debug" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "$1" "$2" "$3" "$4" "$5" "debug" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "$1" "$2" "$3" "$4" "$5" "debug" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "$1" "$2" "$3" "$4" "$5" "debug" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "$1" "$2" "$3" "$4" "$5" "debug" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "$1" "$2" "$3" "$4" "$5" "debug" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_start_lower)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "" "" "" "" "" "special_start_lower" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_ps1 "" "" "" "" "" "special_start_lower" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                ;;
        special_start_title)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "" "" "" "" "" "special_start_title" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "" "" "" "" "" "special_start_title" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_start_upper)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "" "" "" "" "" "special_start_upper" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_ps1 "" "" "" "" "" "special_start_upper" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                ;;
        special_change_start)
                ##___hex_value="$1"
                ##___indent_level="$2"
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ##___hex_value="$1"
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___indent-level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "" "" "" "$2" "special_change_start" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "$1" "" "" "" "$2" "special_change_start" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "$1" "" "" "" "$2" "special_change_start" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "$1" "" "" "" "$2" "special_change_start" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "$1" "" "" "" "$2" "special_change_start" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "$1" "" "" "" "$2" "special_change_start" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_change)
                ##___hex_value="$1"
                ##___indent_level="$2"
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ##___hex_value="$1"
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___indent_level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "" "" "" "$2" "special_change" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "$1" "" "" "" "$2" "special_change" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "$1" "" "" "" "$2" "special_change" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "$1" "" "" "" "$2" "special_change" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "$1" "" "" "" "$2" "special_change" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "$1" "" "" "" "$2" "special_change" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_content_lowercase)
                ##___lowercase="$1"
                ## ... unused ...
                ##___indent_level="$3"
                ##___scanned="$4"
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ##___lowercase="$1"
                ## ... unused ...
                ##___scanned="$3"
                ## ... unused ...
                ##___indent_level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "" "$4" "" "$3" "special_content" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_ps1 "$1" "" "$4" "" "$3" "special_content" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                ;;
        special_content_titlecase)
                ##___lowercase="$1"
                ##___titlecase="$2"
                ##___indent_level="$3"
                ##___scanned="$4"
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ##___lowercase="$1"
                ##___titlecase="$2"
                ##___scanned="$3"
                ## ... unused ...
                ##___indent_level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "$2" "$4" "" "$3" "special_content_titlecase" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "$1" "$2" "$4" "" "$3" "special_content_titlecase" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_content_uppercase)
                ##___uppercase="$1"
                ## ... unused ...
                ##___indent_level="$3"
                ##___scanned="$4"
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ##___uppercase="$1"
                ## ... unused ...
                ##___scanned="$3"
                ## ... unused ...
                ##___indent_level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "$1" "" "$4" "" "$3" "special_content" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_ps1 "$1" "" "$4" "" "$3" "special_content" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                ;;
        special_change_end)
                ## ... unused ...
                ##___indent_level="$2"
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___indent_level="$5"
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "" "" "" "" "$2" "special_change_end" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "$2" "special_change_end" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "" "" "" "" "$2" "special_change_end" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "" "" "" "" "$2" "special_change_end" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "$2" "special_change_end" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "" "" "" "" "$2" "special_change_end" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        special_end)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ##___restriction="$7"
                print_to_sh "" "" "" "" "" "special_end" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "" "special_end" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_sh "" "" "" "" "" "special_end" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "" "" "" "" "" "special_end" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "" "special_end" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                print_to_ps1 "" "" "" "" "" "special_end" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        data_start)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                #___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                print_to_sh "" "" "" "" "" "data_start" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "" "data_start" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_ps1 "" "" "" "" "" "data_start" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "" "data_start" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                ;;
        data_start_titlecase)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                print_to_sh "" "" "" "" "" "data_start_titlecase" "titlecase" \
                        1>> "$___output_to_title_sh"
                print_to_ps1 "" "" "" "" "" "data_start_titlecase" "titlecase" \
                        1>> "$___output_to_title_ps1"
                ;;
        data_first)
                ##___prev_lower="$1"
                ##___last="$2"
                ##___diff="$3"
                ##___direction="$4"
                ##___status="$5"
                ##___restriction="$6"
                ##
                ## TO:
                ##
                ##___prev_lower="$1"
                ##___last="$2"
                ##___diff="$3"
                ##___direction="$4"
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                case "$6" in
                lower*)
                        ___output_sh="$___output_to_lower_sh"
                        ___output_ps1="$___output_to_lower_ps1"
                        ;;
                upper*)
                        ___output_sh="$___output_to_upper_sh"
                        ___output_ps1="$___output_to_upper_ps1"
                        ;;
                title*)
                        ___output_sh="$___output_to_title_sh"
                        ___output_ps1="$___output_to_title_ps1"
                        ;;
                *)
                        1>&2 printf -- "[ ERROR ] data_first state requires explicit case |%b|\n" \
                                        "$6"
                        exit 1
                        ;;
                esac

                print_to_sh "$1" "$2" "$3" "$4" "" "data_first" "$6" 1>> "$___output_sh"
                print_to_ps1 "$1" "$2" "$3" "$4" "" "data_first" "$6" 1>> "$___output_ps1"
                ;;
        data_within)
                ##___prev_lower="$1"
                ##___last="$2"
                ##___diff="$3"
                ##___direction="$4"
                ##___status="$5"
                ##___restriction="$6"
                ##
                ## TO:
                ##
                ##___prev_lower="$1"
                ##___last="$2"
                ##___diff="$3"
                ##___direction="$4"
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                case "$6" in
                lower*)
                        ___output_sh="$___output_to_lower_sh"
                        ___output_ps1="$___output_to_lower_ps1"
                        ;;
                upper*)
                        ___output_sh="$___output_to_upper_sh"
                        ___output_ps1="$___output_to_upper_ps1"
                        ;;
                title*)
                        ___output_sh="$___output_to_title_sh"
                        ___output_ps1="$___output_to_title_ps1"
                        ;;
                *)
                        1>&2 printf -- "[ ERROR ] data_first state requires explicit case |%b|\n" \
                                        "$6"
                        exit 1
                        ;;
                esac

                print_to_sh "$1" "$2" "$3" "$4" "" "data_within" "$6" 1>> "$___output_sh"
                print_to_ps1 "$1" "$2" "$3" "$4" "" "data_within" "$6" 1>> "$___output_ps1"
                ;;
        data_end)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                print_to_sh "" "" "" "" "$___indent" "data_end" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "$___indent" "data_end" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_ps1 "" "" "" "" "$___indent" "data_end" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "$___indent" "data_end" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                ;;
        end)
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$5"
                ## ... unused ...
                ##
                ## TO:
                ##
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ## ... unused ...
                ##___status="$6"
                ## ... unused ...

                # NOTICE
                # titlecase is not required because its 'data_start_titlecase'
                # already close the function (it's using lowercase and uppercase
                # counterparts for its 1:1 transformation regardless).
                sync
                print_to_sh "" "" "" "" "$___indent" "end" "lowercase" \
                        1>> "$___output_to_lower_sh"
                print_to_sh "" "" "" "" "$___indent" "end" "uppercase" \
                        1>> "$___output_to_upper_sh"
                print_to_ps1 "" "" "" "" "$___indent" "end" "lowercase" \
                        1>> "$___output_to_lower_ps1"
                print_to_ps1 "" "" "" "" "$___indent" "end" "uppercase" \
                        1>> "$___output_to_upper_ps1"
                ;;
        *)
                # ERROR - do nothing
                1>&2 printf -- "[ ERROR ] unknown write state!\n"
                exit 1
                ;;
        esac
}




# This is an internal function consumed by 'parse_special_file' function mainly
# for processing the sorted and generated special casing characters database
# into an actual output.
#
# By default, unless the database is modified, this function shall not need
# any modifications. If there are bugs related to the printer, then the printer
# functions are the one requires update. Similarly, if there unicode.org related
# changes, then the 'parse_special_file' function is the one requires update.
#
# The point is: alteration is rare.
#
# Due to its recursive deployment, positioning of the parameters are very
# important. Do not modify unless you do for all the chains.
___process_db_special_directory() {
        #___count_indent="$1"
        #___db_path="$2"
        #___prev="$3"
        #___prev_next="$4"
        #___prev_third="$5"


        # execute
        ___indent_level="$1"
        ___prev="$3"
        ___prev_next="$4"
        ___prev_third="$5"


        # scan recursively into sub-directories first
        for ___target in "${2}"/*; do
                if [ ! -e "$___target" ]; then
                        continue
                fi

                if [ ! -d "$___target" ]; then
                        continue
                fi

                ___process_db_special_directory "$___indent_level" \
                        "$___target" \
                        "$___prev" \
                        "$___prev_next" \
                        "$___prev_third"
        done


        ## process all leaf files
        ___done_lower=""
        ___done_title=""
        ___done_upper=""
        for ___target in "${2}"/*; do
                if [ ! -e "$___target" ]; then
                        continue
                fi

                if [ ! -f "$___target" ]; then
                        continue
                fi


                # arrived at leaf directory - process file
                ___chars="${___target##*/}"


                # parse conversion direction
                ___direction="${___chars%%_*}"
                ___chars="${___chars#"${___direction}"}"
                if [ "${___chars%"${___chars#?}"}" = "_" ]; then
                        ___chars="${___chars#_}"
                fi


                # validate multiple variants
                case "$___direction" in
                lower)
                        if [ ! "$___done_lower" = "" ]; then
                                1>&2 printf -- "[ ERROR ] multiple lower variant: %b\n" "$___target"
                                exit 1
                        fi
                        ___done_lower="true"
                        ;;
                upper)
                        if [ ! "$___done_upper" = "" ]; then
                                1>&2 printf -- "[ ERROR ] multiple upper variant: %b\n" "$___target"
                                exit 1
                        fi
                        ___done_upper="true"
                        ;;
                title)
                        if [ ! "$___done_title" = "" ]; then
                                1>&2 printf -- "[ ERROR ] multiple title variant: %b\n" "$___target"
                                exit 1
                        fi
                        ___done_title="true"
                        ;;
                *)
                        1>&2 printf -- "[ ERROR ] corrupted data file: %b\n" "$___target"
                        exit 1
                        ;;
                esac


                # process data
                ___third="${___target%/*}"
                ___third="x${___third#*/x}"
                ___current="${___third%%/*}"
                ___third="${___third#*"${___current}"}"
                if [ "${___third%"${___third#?}"}" = "/" ]; then
                        ___third="${___third#/}"
                fi
                ___current="0${___current}"

                if [ "$___third" = "" ]; then
                        # 1 character only
                        ___next=""
                        ___third=""
                elif [ ! "${___third#*/}" = "" ]; then
                        # 3 characters only
                        ___next="${___third%%/*}"
                        ___third="${___third#*"${___next}"}"
                        if [ "${___third%"${___third#?}"}" = "/" ]; then
                                ___third="${___third#/}"
                        fi

                        ___next="0${___next}"
                        if [ ! "$___third" = "" ]; then
                                ___third="0${___third}"
                        fi
                else
                        # 2 characters only
                        if [ ! "$___third" = "" ]; then
                                ___next="0$___third"
                        fi
                        ___third=""
                fi


                # output logics to file
                if [ ! "$DEBUG_MODE" = "" ]; then
                        print_output "$___target" \
                                "${___prev}_${___prev_next}_${___prev_third}" \
                                "${___current}_${___next}_${___third}" \
                                "" \
                                "debug"
                fi

                if [ "$___prev" = "$___current" ] &&
                        [ "$___prev_next" = "$___next" ] &&
                        [ "$___prev_third" = "$___third" ]; then
                        : # continue status quo - do nothing
                elif [ "$___prev" = "$___current" ] &&
                        [ "$___prev_next" = "$___next" ] &&
                        [ ! "$___prev_third" = "$___third" ]; then
                        # third depth change
                        ___indent_level=3

                        if [ ! "$___prev_third" = "" ] && [ "$___third" = "" ]; then
                                ___third="any"
                        fi

                        if [ "$___prev_third" = "" ]; then
                                print_output "$___third" "3" "" "" "special_change_start"
                        elif [ "$___prev_third" = "any" ]; then
                                : # DO NOTHING
                        else
                                print_output "$___third" "3" "" "" "special_change"
                        fi
                elif [ "$___prev" = "$___current" ] && [ ! "$___prev_next" = "$___next" ]; then
                        # second depth change
                        ___indent_level=2

                        if [ ! "$___prev_next" = "" ] && [ "$___next" = "" ]; then
                                ___next="any"
                        fi

                        ## close the 3rd-level switch when required
                        if [ ! "$___prev_third" = "" ]; then
                                if [ "$___prev_third" = "any" ] ||
                                        [ ! "$___prev_third" = "$___third" ] ||
                                        [ ! "$___prev_next" = "$___next" ]; then
                                        print_output "" "3" "" "" "special_change_end"
                                fi
                        fi

                        ## perform 2nd-level changes
                        if [ "$___prev_next" = "" ]; then
                                print_output "$___next" "2" "" "" "special_change_start"
                        elif [ "$___prev_next" = "any" ]; then
                                : # DO NOTHING
                        else
                                print_output "$___next" "2" "" "" "special_change"
                        fi

                        ## open the 3rd-level switch when required
                        if [ ! "$___third" = "" ]; then
                                print_output "$___third" "3" "" "" "special_change_start"
                                ___indent_level=3
                        fi
                elif [ ! "$___prev" = "$___current" ]; then
                        # first depth change
                        ___indent_level=1

                        if [ ! "$___prev" = "" ] && [ "$___current" = "" ]; then
                                ___current="any"
                        fi

                        ## close the 3rd-level switch when required
                        if [ ! "$___prev_third" = "" ]; then
                                if [ "$___prev_third" = "any" ] ||
                                        [ ! "$___prev_third" = "$___third" ] ||
                                        [ ! "$___prev_next" = "$___next" ]; then
                                        print_output "" "3" "" "" "special_change_end"
                                fi
                        fi

                        ## close the 2nd-level switch when required
                        if [ ! "$___prev_next" = "" ]; then
                                if [ "$___prev_next" = "any" ] ||
                                        [ ! "$___prev_next" = "$___next" ] ||
                                        [ ! "$___prev" = "$___current" ]; then
                                        print_output "" "2" "" "" "special_change_end"
                                fi
                        fi

                        ## perform 1st-level changes
                        if [ "$___prev" = "" ]; then
                                print_output "$___current" "1" "" "" "special_change_start"
                        elif [ "$___prev" = "any" ]; then
                                : # DO NOTHING
                        else
                                print_output "$___current" "1" "" "" "special_change"
                        fi

                        ## open the 2nd-level switch when required
                        if [ ! "$___next" = "" ]; then
                                print_output "$___next" "2" "" "" "special_change_start"
                                ___indent_level=2
                        fi

                        ## open the 3rd-level switch when required
                        if [ ! "$___third" = "" ]; then
                                print_output "$___third" "3" "" "" "special_change_start"
                                ___indent_level=3
                        fi
                else
                        1>&2 printf -- "[ ERROR ] weird io in database for: %b\n" "$___target"
                        exit 1
                fi


                # process all output characters' data
                ___scanned=$___indent_level
                if [ "$___third" = "any" ] || [ "$___next" = "any" ]; then
                        ___scanned=$(($___indent_level - 1))
                elif [ "$___current" = "any" ]; then
                        ___scanned=1
                fi

                case "$___direction" in
                lower)
                        print_output "$___chars" \
                                "" \
                                "$___indent_level" \
                                "$___scanned" \
                                "special_content_lowercase"
                        ;;
                upper)
                        print_output "$___chars" \
                                "" \
                                "$___indent_level" \
                                "$___scanned" \
                                "special_content_uppercase"
                        ;;
                title)
                        print_output "${___chars%%_to_*}" \
                                "${___chars##*_to_}" \
                                "$___indent_level" \
                                "$___scanned" \
                                "special_content_titlecase"
                        ;;
                *)
                        1>&2 printf -- "[ ERROR ] corrupted data direction: %b\n" "$___target"
                        exit 1
                        ;;
                esac


                # track cases statuses
                ___prev="$___current"
                ___prev_next="$___next"
                ___prev_third="$___third"
        done
}




# This function is the input processing only function parsing the
# SpecialCasing.txt from unicode.org and formulate the unicode lookup database
# (db_special). If there are changes comes from unicode.org (e.g. change of
# encoding formats), only this function is affected.
#
# Duly noted that this function calls the internal recursive file scanning
# function as an output (___process_db_special_directory 1 "$2"). That's where
# it hands off from the output processing to it.
#
# A healthy database shall:
#       (1) has 1 type of any one of title_*, lower*, or upper* (as in no 2 or
#           more of same types) per permutation and only a maximum of 2 types
#           should appear (where the subject is either a lowercase, uppercase,
#           and/or titlecase); AND
#
#       (2) has all casing permutations listed out as independent entries rather
#           than hiding them (no split between lowercase, uppercase, or
#           titlecase); AND
#
#       (3) each hexadecimal values shall prefix-ed with its 'x', not '0x'; AND
#
#       (4) for titlecase, both lowercase and titlecase hex values are listed
#           on the same file separated with the constant '_to_' separator using
#           this pattern 'title_[LOWER]_to_[TITLE]' like
#           'title_x1F56_to_x03A5_x0313_x0342'; AND
#
#       (5) No permutation shall have 0 type conversion; AND
#
#       (6) only parse and map the language indepnedent ones. Exit upon
#           detecting language dependent mapping (Keyword in comment:
#           'Language-Sensitive Mappings').
parse_special_file() {
        #___source_file="$1"
        #___db_path="$2"


        # execute
        # create the library file headers
        ___write_status="special_first"


        # parse the file
        ___old_IFS="$IFS"
        while IFS= read -r ___line || [ -n "$___line" ]; do
                # check for language sensitive mapping indicator
                if [ ! "${___line##*Language-Sensitive Mappings}" = "$___line" ]; then
                        # implement manually in the 'special_start' state since
                        # they are the only ones requiring locale switching.
                        break
                fi


                # clean up and trim off early id
                ___line="${___line%%#*}"
                if [ "$___line" = "" ]; then
                        continue
                fi
                ___line="${___line#*; }"


                # get lowercase hexadecimal value
                ___lower="${___line%%; *}"
                ___line="${___line#*; }"


                # get titlecase hexadecimal value
                ___title="${___line%%; *}"
                ___line="${___line#*; }"


                # get uppercase hexadecimal value
                ___upper="${___line%%; *}"
                ___line="${___line#*; }"


                # generate the path and name for lowercase
                ___path=""
                ___name=""
                while [ ! "$___lower" = "" ]; do
                        if [ "${___lower%% *}" = "$___lower" ]; then
                                ## single byte
                                ___name="${___name}_x${___lower}"
                                ___path="${___path}/x${___lower}"
                                ___lower=""
                                continue
                        fi

                        ## multi-bytes
                        ___name="${___name}_x${___lower%% *}"
                        ___path="${___path}/x${___lower%% *}"
                        ___lower="${___lower#*"${___lower%% *} "}"
                done
                ___lower="${___path#/}"
                ___lower_name="${___name#_}"


                # generate the path and name for titlecase
                ___path=""
                ___name=""
                while [ ! "$___title" = "" ]; do
                        if [ "${___title%% *}" = "$___title" ]; then
                                ## single byte
                                ___name="${___name}_x${___title}"
                                ___path="${___path}/x${___title}"
                                ___title=""
                                continue
                        fi

                        ## multi-bytes
                        ___name="${___name}_x${___title%% *}"
                        ___path="${___path}/x${___title%% *}"
                        ___title="${___title#*"${___title%% *} "}"
                done
                ___title="${___path#/}"
                ___title_name="${___name#_}"


                # generate the path and name for uppercase
                ___path=""
                ___name=""
                while [ ! "$___upper" = "" ]; do
                        if [ "${___upper%% *}" = "$___upper" ]; then
                                ## single byte
                                ___name="${___name}_x${___upper}"
                                ___path="${___path}/x${___upper}"
                                ___upper=""
                                continue
                        fi

                        ## multi-bytes
                        ___name="${___name}_x${___upper%% *}"
                        ___path="${___path}/x${___upper%% *}"
                        ___upper="${___upper#*"${___upper%% *} "}"
                done
                ___upper="${___path#/}"
                ___upper_name="${___name#_}"


                # BEGIN MANUAL EDIT ZONE: process unresolved multiple variants cases
                if [ "$___lower_name" = "xFB05" ]; then
                        # "LATIN SMALL LIGATURE LONG S T" and
                        # "LATIN SMALL LIGATURE ST" both are the lowercases
                        # for its only titlecase and only uppercase counterparts
                        # (2 lowercase variants, 1 titlecase variant, 1 uppercase).
                        #
                        # for purely aristic reason, 0xFB06 is selected.
                        ___lower_name="xFB06"
                        ___lower="xFB06"
                elif [ "$___title_name" = "x0399_x0308_x0301" ] ||
                        [ "$___upper_name" = "x0399_x0308_x0301" ]; then
                        # "GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS" has
                        # 2 lowercase variants:
                        # (1) 0x1FD3 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA
                        # (2) 0x0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
                        #
                        # For maximum availability reason, 0x0390 is chosen since
                        # it falls within the "Greek and Coptic" (0370-03FF) script
                        # instead of the "Greek Extended" one.
                        ___lower_name="x0390"
                        ___lower="x0390"
                elif [ "$___title_name" = "x03A5_x0308_x0301" ] ||
                        [ "$___upper_name" = "x03A5_x0308_x0301" ]; then
                        # "GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS" has
                        # 2 lowercase variants:
                        # (1) 0x1FE3 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA
                        # (2) 0x03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
                        #
                        # For maximum availability reason, 0x03B0 is chosen since
                        # it falls within the "Greek and Coptic" (0370-03FF) script
                        # instead of the "Greek Extended" one.
                        ___lower_name="x03B0"
                        ___lower="x03B0"
                fi
                # END MANUAL EDIT ZONE


                # make data paths into database
                mkdir -p "${2}/${___lower}"
                mkdir -p "${2}/${___title}"
                mkdir -p "${2}/${___upper}"


                # write for lower into database
                ___path="${2}/${___title}/lower_${___lower_name}"
                if [ ! -f "$___path" ] && [ ! "$___title" = "" ]; then
                        if [ ! "$___lower_name" = "" ] && [ ! "$___title" = "$___lower" ]; then
                                printf -- "%b\n" "${___lower_name}" >> "$___path"
                        fi
                fi

                ___path="${2}/${___upper}/lower_${___lower_name}"
                if [ ! -f "$___path" ] && [ ! "$___upper" = "" ]; then
                        if [ ! "$___lower_name" = "" ] && [ ! "$___title" = "$___lower" ]; then
                                printf -- "%b\n" "${___lower_name}" >> "$___path"
                        fi
                fi


                # write for title into database
                ___path="${2}/${___lower}/title_${___lower_name}_to_${___title_name}"
                if [ ! -f "$___path" ] && [ ! "$___lower" = "" ]; then
                        if [ ! "$___title_name" = "" ] && [ ! "$___lower" = "$___title" ]; then
                                printf -- "%b\n" "${___title_name}" >> "$___path"
                        elif [ ! "$___upper_name" = "" ] && [ ! "$___lower" = "$___upper" ]; then
                                ___path="${2}/${___lower}/title_${___lowername}_to_${___upper_name}"
                                printf -- "%b\n" "${___upper_name}" >> "$___path"
                        fi
                fi

                ___path="${2}/${___upper}/title_${___lower_name}_to_${___title_name}"
                if [ ! -f "$___path" ] && [ ! "$___upper" = "" ]; then
                        if [ ! "$___title_name" = "" ] && [ ! "$___upper" = "$___title" ]; then
                                printf -- "%b\n" "${___title_name}" >> "$___path"
                        elif [ ! "$___upper_name" = "" ] && [ ! "$___upper" = "$___title" ]; then
                                ___path="${2}/${___upper}/title_${___lower_name}_to_${___upper_name}"
                                printf -- "%b\n" "${___upper_name}" >> "$___path"
                        fi
                fi


                # write for upper into database
                ___path="${2}/${___lower}/upper_${___upper_name}"
                if [ ! -f "$___path" ] && [ ! "$___lower" = "" ]; then
                        if [ ! "$___upper_name" = "" ] && [ ! "$___lower" = "$___upper" ]; then
                                printf -- "%b\n" "${___upper_name}" >> "$___path"
                        elif [ ! "$___title_name" = "" ] && [ ! "$___lower" = "$___title" ]; then
                                ___path="${2}/${___lower}/upper_${___title_name}"
                                printf -- "%b\n" "${___title_name}" >> "$___path"
                        fi
                fi

                ___path="${2}/${___title}/upper_${___upper_name}"
                if [ ! -f "$___path" ] && [ ! "$___title" = "" ]; then
                        if [ ! "$___upper_name" = "" ] && [ ! "$___title" = "$___upper" ]; then
                                printf -- "%b\n" "${___upper_name}" >> "$___path"
                        elif [ ! "$___title_name" = "" ] && [ ! "$___title" = "$___upper" ]; then
                                ___path="${2}/${___title}/upper_${___title_name}"
                                printf -- "%b\n" "${___title_name}" >> "$___path"
                        fi
                fi
        done < "$1"


        # process database
        ___process_db_special_directory "1" "$2"
}




# This function is the only function parsing the UnicodeData.txt from
# unicode.org. If there are changes comes from unicode.org (e.g. change of
# encoding formats), only this function is affected.
#
# Whenever output to file is required, use the 'print_output' function and not
# the printers directly. Example:
#
#       print_output "$___prev" \
#                       "$___last" \
#                       "$___prev_diff" \
#                       "$___direction" \
#                       "$___write_status" \
#                       "$2"
#
# Default algorithm automatically forms ranges instead of listing all to keep
# the generated source codes reader, smaller, compact, and easier to lookup both
# programmatically and reading manually.
parse_data_file() {
        #___source_file="$1"
        #___mode="$2"


        # execute
        # create the library file headers
        ___write_status="data_first"


        # parse the file
        ___prev=0
        ___prev_diff=0
        ___last=0
        ___old_IFS="$IFS"
        while IFS= read -r ___line || [ -n "$___line" ]; do
                # get current decimal
                ___current="${___line%%;*}"
                ___current="$(printf "%d" "0x${___current}")"


                # get direction and corresponder
                ___to_case=""
                ___direction="${___line#*;}"
                ___direction="${___direction%%;*}"
                if [ ! "${___direction##*CAPITAL}" = "$___direction" ]; then
                        ___to_case="${___line%;*}"
                        ___to_case="${___to_case##*;}"
                        ___direction="to lowercase"
                elif [ ! "${___direction##*SMALL}" = "$___direction" ] ||
                        [ ! "${___direction##*LOWER}" = "$___direction" ]; then
                        ___to_case="${___line##*;}"
                        ___direction="to uppercase"
                else
                        # case insensitive character. Skipping...
                        continue
                fi

                if [ "$___to_case" = "" ]; then
                        continue # no case transformation
                fi

                case "$2" in
                lowercase)
                        if [ "$___direction" = "to uppercase" ]; then
                                continue # requested to be filtered out
                        fi
                        ;;
                uppercase)
                        if [ "$___direction" = "to lowercase" ]; then
                                continue # requested to be filtered out
                        fi
                        ;;
                *)
                        # default to both
                        ;;
                esac

                ___to_case="$(printf "%d" "0x${___to_case}")"


                # calculate differences
                if [ $___current -gt $___to_case ]; then
                        ___diff=$(($___current - $___to_case))
                        ___diff=$(($___diff * -1))
                elif [ $___current -lt $___to_case ]; then
                        ___diff=$(($___to_case - $___current))
                fi


                # react appropriately
                if [ $___prev_diff -eq 0 ]; then
                        # started from zero value
                        ___prev=$___current
                        ___prev_diff=$___diff
                elif [ $___prev_diff -eq $___diff ]; then
                        # inside a value zone

                        if [ $(($___current - $___last)) -ne 1 ]; then
                                # new zone with same diff
                                print_output "$___prev" \
                                        "$___last" \
                                        "$___prev_diff" \
                                        "$___direction" \
                                        "$___write_status" \
                                        "$2"
                                ___write_status="data_within"

                                ___last=$___current
                                ___prev=$___current
                                continue
                        fi
                elif [ $___prev_diff -ne $___diff ] || [ $___diff -eq 0 ]; then
                        # new parts with different math calculation
                        print_output "$___prev" \
                                "$___last" \
                                "$___prev_diff" \
                                "$___direction" \
                                "$___write_status" \
                                "$2"
                        ___write_status="data_within"

                        ___prev=$___current
                        ___prev_diff=$___diff
                fi

                ___last=$___current
        done < "$1"
}




# This function executes the entire script. It shall generates, at minimum the
# following files for each supported programming languages:
#
#     (1) rune_to_lower.{extension} - conditional table for lowercase switching
#     (2) rune_to_upper.{extension} - conditional table for uppercase switching
#     (3) rune_to_title.{extension} - conditional table for titlecase switching
#
# All generated artfacts for each programming language SHALL and MUST stay next
# to each other where titlecase depends on its other counter parts outside of
# 1:1 non-special casing.
#
# Generally speaking, this main function only manages the algorithm's high level
# coordinations should not be edited without very good reason.
main() {
        # parse param
        if [ -f "${1-./UnicodeData.txt}" ] && [ -f "${2:-./SpecialCasing.txt}" ]; then
                :
        else
                1>&2 printf -- "\
unicode-data-parser.sh

Place the UnicodeData.txt and SpecialCasing.txt right next to this parser script
then change directory into the script (current directory should be the these
3 files. Then run either:

production mode : $ ./unicode-data-parser.sh
debug mode      : $ DEBUG_MODE=true ./unicode-data-parser.sh

OPTIONAL POSITIONAL ARGUMENTS
[1] custom filepath to UnicodeData.txt source file (default is: './UnicodeData.txt').
[2] custom filepath to SpecialCasing.txt source file (default is: './SpecialCasing.txt').
"
                exit 1
        fi


        # execute
        # start the generators
        print_output "" "" "" "" "start"
        if [ $? -ne 0 ]; then
                exit 1
        fi


        # parse the special casing data file
        ___path_db="./db_special"
        rm -rf "$___path_db" &> /dev/null
        sync

        print_output "" "" "" "" "special_start_lower"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        print_output "" "" "" "" "special_start_title"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        print_output "" "" "" "" "special_start_upper"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        parse_special_file "${2:-./SpecialCasing.txt}" "$___path_db"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        print_output "" "" "" "" "special_end"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        if [ "$DEBUG_MODE" = "" ]; then
                rm -rf "$___path_db" &> /dev/null
                sync
        fi


        # parse the non-special 1:1 casing data file
        print_output "" "" "" "" "data_start"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        print_output "" "" "" "" "data_start_titlecase"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        parse_data_file "${1-./UnicodeData.txt}" "lowercase"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        parse_data_file "${1-./UnicodeData.txt}" "uppercase"
        if [ $? -ne 0 ]; then
                exit 1
        fi

        print_output "" "" "" "" "data_end"
        if [ $? -ne 0 ]; then
                exit 1
        fi


        # close the generators
        print_output "" "" "" "" "end"
        if [ $? -ne 0 ]; then
                exit 1
        fi
}
main "$@"
